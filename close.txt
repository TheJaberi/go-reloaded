package test

import (
	"bytes"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: go run main.go <input_file> <output_file>")
		return
	}

	inputFile := os.Args[1]
	outputFile := os.Args[2]

	text, err := readTextFromFile(inputFile)
	if err != nil {
		fmt.Printf("Error reading input file: %v\n", err)
		return
	}

	modifiedText := processText(text)
	err = writeTextToFile(modifiedText, outputFile)
	if err != nil {
		fmt.Printf("Error writing to output file: %v\n", err)
		return
	}

	fmt.Println("Text processing complete.")
}

func readTextFromFile(filename string) (string, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func writeTextToFile(text, filename string) error {
	return os.WriteFile(filename, []byte(text), 0644)
}

func processText(text string) string {

	// Replace 'a' with 'an' if the next word starts with a vowel or 'h'
	text = replaceAToAn(text)

	// Replace (hex) with decimal version of the preceding word
	text = replaceHexNumbers(text)

	// Replace (bin) with decimal version of the preceding word
	text = replaceBinaryNumbers(text)

	// Convert the preceding word to uppercase if (up) is found
	text = convertToUppercase(text)

	// Convert the preceding word to lowercase if (low) is found
	text = convertToLowercase(text)

	// Capitalize the preceding word if (cap) is found
	text = convertToCapitalized(text)

	// Remove the marker tags from the text
	text = removeMarkers(text)

	// Format punctuations with preceding and following words
	text = formatPunctuation(text)

	// Format the ' marks with the corresponding words
	text = formatQuotationMarks(text)

	return text
}

func replaceHexNumbers(text string) string {
	re := regexp.MustCompile(`(\w+) \(hex\)`)
	return re.ReplaceAllStringFunc(text, func(match string) string {
		hex := strings.TrimSuffix(match, " (hex)")
		decimal := convertHexToDecimal(hex)
		return strings.Replace(match, hex, decimal, 1)
	})
}

func replaceBinaryNumbers(text string) string {
	re := regexp.MustCompile(`(\w+) \(bin\)`)
	return re.ReplaceAllStringFunc(text, func(match string) string {
		binary := strings.TrimSuffix(match, " (bin)")
		decimal := convertBinaryToDecimal(binary)
		return strings.Replace(match, binary, decimal, 1)
	})
}

func convertToUppercase(text string) string {
	re := regexp.MustCompile(`((?:\w+ ){0,}\w+) \(up(?:, (\d+))?\)`)
	return re.ReplaceAllStringFunc(text, func(match string) string {
		submatches := re.FindStringSubmatch(match)
		wordsMatch := submatches[1]
		count := submatches[2]

		words := strings.Fields(wordsMatch)

		if count == "" {
			words[len(words)-1] = strings.ToUpper(words[len(words)-1])
		} else {
			num, err := strconv.Atoi(count)
			if err != nil {
				return match
			}

			for i := len(words) - 1; i >= 0 && num > 0; i-- {
				words[i] = strings.ToUpper(words[i])
				num--
			}
		}

		return strings.Join(words, " ")
	})
}

func convertToLowercase(text string) string {
	re := regexp.MustCompile(`((?:\w+ ){0,}\w+) \(low(?:, (\d+))?\)`)
	return re.ReplaceAllStringFunc(text, func(match string) string {
		submatches := re.FindStringSubmatch(match)
		wordsMatch := submatches[1]
		count := submatches[2]

		words := strings.Fields(wordsMatch)

		if count == "" {
			words[len(words)-1] = strings.ToLower(words[len(words)-1])
		} else {
			num, err := strconv.Atoi(count)
			if err != nil {
				return match
			}

			for i := len(words) - 1; i >= 0 && num > 0; i-- {
				words[i] = strings.ToLower(words[i])
				num--
			}
		}

		return strings.Join(words, " ")
	})
}

func convertToCapitalized(text string) string {
	re := regexp.MustCompile(`((?:\w+ ){0,}\w+) \(cap(?:, (\d+))?\)`)
	return re.ReplaceAllStringFunc(text, func(match string) string {
		submatches := re.FindStringSubmatch(match)
		wordsMatch := submatches[1]
		count := submatches[2]

		words := strings.Fields(wordsMatch)

		if count == "" {
			words[len(words)-1] = strings.Title(words[len(words)-1])
		} else {
			num, err := strconv.Atoi(count)
			if err != nil {
				return match
			}

			for i := len(words) - 1; i >= 0 && num > 0; i-- {
				words[i] = strings.Title(words[i])
				num--
			}
		}

		return strings.Join(words, " ")
	})
}

func formatPunctuation(text string) string {
	// Create a map to quickly look up whether a character is punctuation
	punctuationMap := map[rune]bool{
		'.': true,
		',': true,
		'!': true,
		'?': true,
		':': true,
		';': true,
	}

	runes := []rune(text)
	n := len(runes)

	// Start by creating a buffer to build the formatted text
	var buffer bytes.Buffer
	buffer.Grow(n) // Pre-allocate the required space

	i := 0
	for i < n {
		r := runes[i]

		if punctuationMap[r] {
			// Special handling for '...'
			if r == '.' && i+2 < n && runes[i+1] == '.' && runes[i+2] == '.' {
				buffer.WriteRune(runes[i])
				buffer.WriteRune(runes[i+1])
				buffer.WriteRune(runes[i+2])
				i += 3
				continue
			}

			// Check if the character before the punctuation is a space and remove it
			if i > 0 && runes[i-1] == ' ' {
				buffer.Truncate(buffer.Len() - 1)
			}

			// Write the punctuation to the buffer
			buffer.WriteRune(r)

			// Skip the space after the punctuation
			if i+1 < n && runes[i+1] == ' ' {
				i++
			}
		} else {
			buffer.WriteRune(r)
		}

		i++
	}

	return buffer.String()
}

func formatQuotationMarks(text string) string {
	re := regexp.MustCompile(`'([^']*)'`)
	return re.ReplaceAllString(text, "'$1'")
}

func replaceAToAn(text string) string {
	re := regexp.MustCompile(`(?i)\ba\s+([aeiouh])`)
	return re.ReplaceAllStringFunc(text, func(match string) string {
		return strings.Replace(match, "a ", "an ", 1)
	})
}

func removeMarkers(text string) string {
	markerRe := regexp.MustCompile(`\((\w+)(?:,\s*\d+)?\)`)
	return markerRe.ReplaceAllString(text, "")
}

func normalizeSpacing(text string) string {
	// Remove extra spaces before punctuation marks
	text = regexp.MustCompile(`\s+([.,!?;:])`).ReplaceAllString(text, "$1")

	// Add space after punctuation marks if not followed by whitespace
	text = regexp.MustCompile(`([.,!?;:])\S`).ReplaceAllString(text, "$1 ")

	return text
}

func convertHexToDecimal(hex string) string {
	// Assuming hex is a valid hexadecimal number
	decimal := fmt.Sprintf("%d", convertBaseToDecimal(hex, 16))
	return decimal
}

func convertBinaryToDecimal(binary string) string {
	// Assuming binary is a valid binary number
	decimal := fmt.Sprintf("%d", convertBaseToDecimal(binary, 2))
	return decimal
}

func convertBaseToDecimal(number string, base int) int64 {
	// Assuming number is a valid number in the specified base
	var result int64
	for _, digit := range number {
		value := int64(digit) - '0'
		result = result*int64(base) + value
	}
	return result
}
