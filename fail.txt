package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
	"unicode"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: go run main.go <input_file> <output_file>")
		return
	}

	inputFile := os.Args[1]
	outputFile := os.Args[2]

	text, err := readTextFromFile(inputFile)
	if err != nil {
		fmt.Printf("Error reading input file: %v\n", err)
		return
	}

	modifiedText := processText(text)
	err = writeTextToFile(modifiedText, outputFile)
	if err != nil {
		fmt.Printf("Error writing to output file: %v\n", err)
		return
	}

	fmt.Println("Text processing complete.")
}

func readTextFromFile(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer file.Close()

	var text strings.Builder
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		text.WriteString(scanner.Text())
		text.WriteString("\n")
	}
	if err := scanner.Err(); err != nil {
		return "", err
	}

	return text.String(), nil
}

func writeTextToFile(text string, filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	_, err = writer.WriteString(text)
	if err != nil {
		return err
	}

	err = writer.Flush()
	if err != nil {
		return err
	}

	return nil
}

func processText(text string) string {
	lines := strings.Split(text, "\n")
	resultLines := make([]string, len(lines))

	for i, line := range lines {
		words := strings.Fields(line)
		resultWords := make([]string, len(words))

		for j, word := range words {
			prevWord := ""
			if j > 0 {
				prevWord = words[j-1]
			}

			// Handle (hex) marker
			if word == "(hex)" {
				if j > 0 {
					prevWord = convertHexToDecimal(prevWord)
				}
				continue
			}

			// Handle (bin) marker
			if word == "(bin)" {
				if j > 0 {
					prevWord = convertBinaryToDecimal(prevWord)
				}
				continue
			}

			// Handle (up) marker
			if word == "(up)" {
				if j > 0 {
					prevWord = strings.ToUpper(prevWord)
				}
				continue
			}

			// Handle (low) marker
			if word == "(low)" {
				if j > 0 {
					prevWord = strings.ToLower(prevWord)
				}
				continue
			}

			// Handle (cap) marker
			if word == "(cap)" {
				if j > 0 {
					prevWord = strings.Title(prevWord)
				}
				continue
			}

			// Handle (low, <number>) marker
			if strings.HasPrefix(word, "(low,") {
				parts := strings.Split(word, ",")
				if len(parts) == 2 {
					countStr := strings.TrimSpace(parts[1])
					count, err := strconv.Atoi(countStr)
					if err == nil {
						for k := j - count; k < j; k++ {
							if k >= 0 && k < len(words) {
								words[k] = strings.ToLower(words[k])
							}
						}
					}
				}
				continue
			}

			// Handle (up, <number>) marker
			if strings.HasPrefix(word, "(up,") {
				parts := strings.Split(word, ",")
				if len(parts) == 2 {
					countStr := strings.TrimSpace(parts[1])
					count, err := strconv.Atoi(countStr)
					if err == nil {
						for k := j - count; k < j; k++ {
							if k >= 0 && k < len(words) {
								words[k] = strings.ToUpper(words[k])
							}
						}
					}
				}
				continue
			}

			// Handle (cap, <number>) marker
			if strings.HasPrefix(word, "(cap,") {
				parts := strings.Split(word, ",")
				if len(parts) == 2 {
					countStr := strings.TrimSpace(parts[1])
					count, err := strconv.Atoi(countStr)
					if err == nil {
						for k := j - count; k < j; k++ {
							if k >= 0 && k < len(words) {
								words[k] = strings.Title(words[k])
							}
						}
					}
				}
				continue
			}

			// Handle punctuation marks
			if isPunctuationMark(word) {
				if j > 0 {
					prevWord = removeExtraSpaces(prevWord)
				}
				resultWords[j] = prevWord + word
			} else {
				resultWords[j] = word
			}
		}

		resultLines[i] = strings.Join(resultWords, " ")
	}

	return strings.Join(resultLines, "\n")
}

func convertHexToDecimal(hex string) string {
	// Remove leading "0x" if present
	hex = strings.TrimPrefix(hex, "0x")

	// Convert hexadecimal to decimal
	dec, err := strconv.ParseInt(hex, 16, 64)
	if err != nil {
		return hex
	}

	return strconv.FormatInt(dec, 10)
}

func convertBinaryToDecimal(binary string) string {
	// Remove leading "0b" if present
	binary = strings.TrimPrefix(binary, "0b")

	// Convert binary to decimal
	dec, err := strconv.ParseInt(binary, 2, 64)
	if err != nil {
		return binary
	}

	return strconv.FormatInt(dec, 10)
}

func isPunctuationMark(word string) bool {
	if len(word) == 1 && unicode.IsPunct([]rune(word)[0]) {
		return true
	}

	return false
}

func removeExtraSpaces(word string) string {
	word = strings.TrimSpace(word)
	word = strings.TrimRight(word, ".,;:!?")

	return word
}
